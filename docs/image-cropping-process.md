# Image Cropping and Storage Process

## Overview
This document explains how image cropping works in the application, where images are stored, and what happens to old images.

## Aspect Ratios

### Cover Images
- **EntityHeader Display**: `aspect-[1344/500]` (approximately 2.69:1)
- **ImageCropper**: `1344/500` (matches EntityHeader exactly)
- **Preview Container**: `aspect-[1344/500]` (matches EntityHeader exactly)
- **Output Dimensions**: Exactly 1344x500 pixels

### Avatar Images
- **Display**: `1:1` (square)
- **ImageCropper**: `1:1` (square)

## Image Quality and Size Requirements

### Size Guidelines
- **Cover Images**: Must be saved at exactly 1344x500 pixels to match header display
- **Avatar Images**: Must maintain 1:1 aspect ratio (square)
- **Output Dimensions**: Cover images are always 1344x500 pixels regardless of source crop area size

### Quality Settings
- **JPEG Quality**: 95% for maximum quality
- **Next.js Image**: 95% quality setting
- **Cloudinary Upload**: 95% quality with auto format optimization
- **Canvas Output**: Exactly 1344x500 pixels for cover images

## Image Storage Process

### 1. Upload Process
When a user uploads a new image:

1. **File Selection**: User selects an image file
2. **Preview**: Image is displayed in preview container with correct aspect ratio
3. **Cropping (Optional)**: User can crop/adjust the image using ImageCropper
4. **Output Generation**: Cropped image is saved at exactly 1344x500 pixels for covers
5. **Upload**: Image is uploaded to Cloudinary with high quality settings

### 2. Cloudinary Storage
- **Format**: JPEG with 95% quality, auto format optimization
- **Storage Path**: `authorsinfo/{entityType}_{type}` (e.g., `authorsinfo/book_cover`)
- **Upload Preset**: `authorsinfo`
- **Public ID**: Auto-generated by Cloudinary
- **Optimization**: Automatic WebP/AVIF conversion for supported browsers
- **Cover Image Size**: Exactly 1344x500 pixels

### 3. Database Storage
- **Table**: `images`
- **Fields Stored**:
  - `url`: Cloudinary secure URL
  - `alt_text`: Descriptive text
  - `img_type_id`: Type identifier (40 for book_cover, 41 for book_avatar, etc.)
  - `storage_provider`: "cloudinary"
  - `storage_path`: Cloudinary folder path
  - `original_filename`: Original file name
  - `file_size`: File size in bytes
  - `mime_type`: File MIME type
  - `is_processed`: true
  - `processing_status`: "completed"

### 4. Entity Update
- **Table**: `{entityType}s` (e.g., `books`, `authors`, etc.)
- **Field**: `{type}_image_id` (e.g., `cover_image_id`, `avatar_image_id`)
- **Value**: ID of the newly created image record

## Old Image Cleanup

### Automatic Cleanup
When a new image is uploaded to replace an existing one:

1. **Check**: If the old image URL contains "cloudinary.com"
2. **Extract**: Public ID from the Cloudinary URL
3. **Delete**: Call Cloudinary API to delete the old image
4. **Log**: Success/failure of deletion (doesn't fail upload if deletion fails)

### Manual Cleanup
- Old images are **NOT automatically deleted** from Cloudinary
- This provides a safety net in case of upload failures
- Manual cleanup can be done through Cloudinary dashboard

## CORS Handling

### Cross-Origin Issues
- External images (Cloudinary URLs) can cause "Tainted canvas" errors
- **Solution**: Use `crossOrigin="anonymous"` on image elements
- **Fallback**: If crossOrigin fails, try without it
- **Error Handling**: If all fails, return original image URL

### ImageCropper CORS Fix
```typescript
// Create a new image with crossOrigin to avoid CORS issues
const img = new Image()
img.crossOrigin = 'anonymous'

img.onload = () => {
  // Draw the cropped image
  ctx.drawImage(img, sourceX, sourceY, sourceWidth, sourceHeight, 0, 0, outputWidth, outputHeight)
  
  // Convert to blob and create URL with higher quality
  canvas.toBlob((blob) => {
    if (blob) {
      const croppedImageUrl = URL.createObjectURL(blob)
      onCrop(croppedImageUrl)
    }
  }, 'image/jpeg', 0.95)
}

img.onerror = () => {
  // Fallback: try without crossOrigin
  const fallbackImg = new Image()
  fallbackImg.onload = () => {
    // ... same drawing logic
  }
  fallbackImg.src = imageUrl
}

img.src = imageUrl
```

## File Formats

### Supported Input Formats
- JPEG (.jpg, .jpeg)
- PNG (.png)
- GIF (.gif)
- WebP (.webp)
- SVG (.svg)

### Output Format
- **Primary**: JPEG with 95% quality
- **Optimized**: WebP/AVIF for supported browsers
- **Reason**: Better compression, smaller file sizes, universal compatibility

## Next.js Configuration

### Image Optimization
```javascript
// next.config.mjs
images: {
  remotePatterns: [
    {
      protocol: 'https',
      hostname: 'res.cloudinary.com',
      port: '',
      pathname: '/**',
    },
  ],
  formats: ['image/webp', 'image/avif'],
  minimumCacheTTL: 60,
}
```

### Display Settings
- **Quality**: 95%
- **Sizes**: Responsive sizing for all viewport widths
- **Priority**: High priority loading for cover images
- **Object Fit**: `object-cover` for proper aspect ratio maintenance

## Error Handling

### Upload Failures
- **Network Errors**: Retry mechanism with user notification
- **File Size**: 5MB limit with clear error message
- **Format Issues**: Client-side validation before upload
- **Cloudinary Errors**: Detailed error logging and user feedback

### CORS Errors
- **Primary**: Use crossOrigin="anonymous"
- **Fallback**: Try without crossOrigin
- **Final**: Return original image URL

### Database Errors
- **Image Insert**: Rollback upload if database insert fails
- **Entity Update**: Log error but don't fail upload
- **Old Image Deletion**: Log warning but don't fail upload

## Performance Considerations

### Image Optimization
- **Client-side**: Canvas-based cropping reduces server load
- **Cloudinary**: Automatic optimization and CDN delivery
- **Database**: Efficient queries with proper indexing
- **Next.js**: Automatic format optimization and responsive images

### Memory Management
- **Blob URLs**: Automatically cleaned up by browser
- **Canvas**: Reused for multiple crops
- **File Objects**: Converted to blobs only when needed

## Security

### File Validation
- **Client-side**: File type and size validation
- **Server-side**: Cloudinary handles additional validation
- **Database**: SQL injection protection via Supabase

### Access Control
- **Authentication**: Required for image uploads
- **Authorization**: Role-based access (admin for editing)
- **CORS**: Properly configured for external resources 